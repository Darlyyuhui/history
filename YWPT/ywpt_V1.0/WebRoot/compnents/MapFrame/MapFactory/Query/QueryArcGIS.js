MapFactory.Define("MapFactory/Query",[	"MapFactory/QueryAPI*",	"MapFactory/MapManager",	"esri/TimeExtent*",	"esri/tasks/query*",	"esri/tasks/QueryTask*",	"MapFactory/Route",	"MapFactory/Geometry*",	"MapFactory/GeometryUtil",	"esri/SpatialReference*",	"MapFactory/Message*"],function(api,mapManager,timeExtent,query,queryTask,route,geoClass,geoUtil,srClass,messageClass){	return function(){				var _queryParams = new query(),			_url = "",_geometry,_precision = 1,_where,_relationship = query.SPATIAL_REL_INTERSECTS,			_mapManager = mapManager(),			_geoUtil = geoUtil();		_queryParams.returnGeometry = true;		_queryParams.outFields = ["*"];		_queryParams.outSpatialReference = new srClass(_mapManager.getSpatialReferenceCode());		function setUrl(url){			_url = url;		}		function setGeometry(geometry){			_geometry = geoUtil().convertFromMapFactory(geometry);		}		function setGeometryPrecision(precision){			_precision = precision ? precision : _precision;		}				function setSpatialRelationShip(relationship){			switch(relationship){				case "intersect" : {					_relationship = query.SPATIAL_REL_INTERSECTS;					break;				}				case "overlap" : {					_relationship = query.SPATIAL_REL_OVERLAPS;					break;				}				case "contains" : {					_relationship = query.SPATIAL_REL_CONTAINS;					break;				}				case "closedpoint" : {					_relationship = "closedpoint";					break;				}				default : {					_relationship = query.SPATIAL_REL_INTERSECTS;					break;				}			}		}		function setCondition(obj){			var _condition = "",				_conReg = /[=|>|<]/g,				_conReg2 = /\s+IN\b/g,				_numReg = /\b\d+\b/g,				_conReg3 = /like/g,				i = 0;			for(var elem in obj){				i++;				var _match = elem.match(_conReg),					_match2 = elem.match(_conReg2),					_numMatch = obj[elem].match(_numReg),					_match3 = elem.match(_conReg3),					_quoteStr = "'";				if(i > 1){					_condition += " And ";				}				if(!_match){					if(!_match2){						if(_match3){							_condition += elem.replace(_conReg3,"") + " like " + _quoteStr +"%"+ obj[elem]+"%" + _quoteStr;						}else{							_condition += elem + " = " + _quoteStr + obj[elem] + _quoteStr;						}					}else{						var _fields = elem.replace(_conReg2,""),							_values = obj[elem].split(","),							_valueFlag = 0;						for(var _vIndex=0,_vLen=_values.length;_vIndex<_vLen;_vIndex++){							_valueFlag++;							if(_valueFlag > 1){								_condition += " OR ";							}							_condition += _fields + " = " + _quoteStr + _values[_vIndex] + _quoteStr;						}					}				}else{					_condition += elem.replace(_conReg,"") + _match.toString() + obj[elem];				}			}			_where = _condition;			//console.log(_where);		}		function execute(successFunc,failureFunc){			if(!_url){				if(failureFunc){					failureFunc(new messageClass({						message : "服务地址未设置"					}));				}				return;			}			if(_relationship == "closedpoint") {				// 进行路网投影点查找				var _sx = parseFloat(_geometry.x);				var _sy = parseFloat(_geometry.y);				var xchazhi = (108.942608-108.942123)/2;// x轴上道路宽度的1/2长度				var ychazhi = (34.261199-34.260863)/2;// y轴上道路宽度的1/2长度				var _ex = _sx+xchazhi;				var _ey = _sy+ychazhi;				var _route = route();				_route.setUrl(_url);				_route.setStart(new geoClass({type : "point", points : _sx+","+_sy}));				_route.setEnd(new geoClass({type : "point", points : _ex+","+_ey}));				_route.setStops([]);				_route.setBarriers([]);				_route.solve(function(result){					var rgeo = result[0].geo;					if(rgeo) {						var rps = rgeo.points.split(",");						rgeo.points = rps[0]+","+rps[1];						rgeo.type = "point";						successFunc(result);					}					else {						successFunc(null);					}										//_geometry = result[0].geo;					//_relationship = "intersect";					//execute(successFunc,failureFunc);				}, function(error){					failureFunc(new messageClass({						message : "查询失败"					}));				});				return;			}			var _queryT = new queryTask(_url);			_queryParams.returnGeometry = true;			if(_where){				_queryParams.where = _where;			}			else {				_queryParams.where = "1=1";			}			if(_geometry){				_queryParams.geometry = _geometry;				_queryParams.geometryPrecision = _precision;				_queryParams.spatialRelationship = _relationship;			}			else {				_queryParams.geometry = null;				_queryParams.geometryPrecision = null;				_queryParams.spatialRelationship = null;			}			_queryParams.timeExtent = new timeExtent(new Date(), new Date());			_queryT.execute(_queryParams,function(features){				var gArr = [],					graphicArr = features.features,					size = graphicArr.length;				for(var i=0;i<size;i++){					var att = graphicArr[i].attributes;					if(att.hasOwnProperty("ROAD_NAME"))att.ROADNAME=att.ROAD_NAME;					if(att.hasOwnProperty("ROAD_ID"))att.ROADID=att.ROAD_ID;					att.ID=att.OBJECTID;					att.code=att.CODE;					gArr.push({						geo : _geoUtil.convertFromObject(graphicArr[i].geometry),						attributes : att					});				}				successFunc(gArr);			},function(err){				failureFunc(new messageClass({					message : "查询失败"				}));			});		}		return eval(MapFactory.GenerateAPI(api));	}});