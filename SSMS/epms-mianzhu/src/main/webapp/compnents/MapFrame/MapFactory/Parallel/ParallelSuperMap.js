MapFactory.Define("MapFactory/Parallel",[	"MapFactory/ParallelAPI*",	"MapFactory/GeometryUtil"],function(api,geoUtil){	var proj4326 = new SuperMap.Projection("EPSG:4326");	var proj900913 = new SuperMap.Projection("EPSG:900913");	var wkt = new SuperMap.Format.WKT();		var _geoUtil = geoUtil();	var //缓存坐标转换方法		toXY,		toGeo,				//生成的平行线graphic		graphic;			/*	 * 创建平行线	 * @param geo 需要创建平行线的中心线	 * @param distance 需要创建的平行线离原始线的距离	 * @param side 取值"both", "left", "right"，默认为"both"；	 * */	function createParallel(geo, distance, side){		var paths,						//每条平行线的paths			leftPaths = [],			rightPaths = [],				//当前点与平行线上对应的之间的经纬度差			d={},			//平行线上与当前点对应的点坐标			lx, ly, rx, ry,						//side正确值的集合			sideObj = "both left right",						//平行线及对应的graphic			polylines = [];						//对线的头部和尾部进行加点处理		paths = initPolyline(geo.points);				//distance不存在，则设置默认距离[-10, 10]		if (!distance) {			distance = 10;		}				if (!side || typeof side != "string" || sideObj.indexOf(side) === -1) {			side = "both";		}				toXY = _transform4326to900913;		toGeo = _transform900913to4326;				for(var i = 1, newPathLen = paths.length - 1; i < newPathLen; i = i + 1){			d = getParallelPoint(paths[i - 1], paths[i], paths[i + 1], distance);			if(!d)continue;			tempPoint = toXY(paths[i].x, paths[i].y);			lx = tempPoint.x + d.lng;			ly = tempPoint.y + d.lat;			rx = tempPoint.x - d.lng;			ry = tempPoint.y - d.lat;			leftPaths.push(toGeo(lx, ly));			rightPaths.push(toGeo(rx, ry));		}				// 由于原始数据进行了reverse操作，所以左右方向刚好相反		switch(side) {			case "both":				polylines.push(new SuperMap.Geometry.LineString(leftPaths));				polylines.push(new SuperMap.Geometry.LineString(rightPaths));				break;			case "left":				polylines.push(new SuperMap.Geometry.LineString(rightPaths));				break;			case "right":				polylines.push(new SuperMap.Geometry.LineString(leftPaths));				break;			default:				break;		}				leftPaths = rightPaths = [];		var polyline = new SuperMap.Geometry.MultiLineString(polylines);		return _geoUtil.convertFromObject(wkt.write(new SuperMap.Feature.Vector(polyline)));	}		function _transform4326to900913(x, y) {		var t = new SuperMap.LonLat(x, y);		var a = t.transform(proj4326, proj900913);		return new SuperMap.Geometry.Point(a.lon, a.lat);	}		function _transform900913to4326(x, y) {		var t = new SuperMap.LonLat(x, y);		var a = t.transform(proj900913, proj4326);		return new SuperMap.Geometry.Point(a.lon, a.lat);	}		// 添加起始点，并将点集合转换为点对象	function initPolyline(points){		// 剔除重复点，并组织多线为单线------这里认为该多线为排序好的多线		var newPoints = [];// 不重复的单线的点对象的集合		var paths = points.split("\|");		var prePoint = null;		for(var i=0,len=paths.length; i<len; i++) {			var temps = paths[i].split(",");			for(var j=0,jl=temps.length; j<jl; j+=2) {				var point = new SuperMap.Geometry.Point(parseFloat(temps[j]), parseFloat(temps[j+1]));				if(!prePoint && j == 0) {					// 初始化prePoint					prePoint = point;					newPoints.push(point);				}				if(prePoint.x == point.x && prePoint.y == point.y) {					continue;				}				newPoints.push(point);				prePoint = point;			}		}		var newlen = newPoints.length;		var firstPoint = newPoints[0];		var secondPoint = newPoints[1];		var lastPoint = newPoints[newlen-1];		var lastSecPoint = newPoints[newlen-2];				var newFirPoint = new SuperMap.Geometry.Point(firstPoint.x * 2 - secondPoint.x, firstPoint.y * 2 - secondPoint.y);		var newLastPoint = new SuperMap.Geometry.Point(lastPoint.x * 2 - lastSecPoint.x, lastPoint.y *2 - lastSecPoint.y);		newPoints.unshift(newFirPoint);		newPoints.push(newLastPoint);		return newPoints.reverse();	}		//获取平行线上与当前点相对应的点的坐标,距离默认以米为单位,怎么设置多条平行线？	function getParallelPoint(firPoint, secPoint, thiPoint, distance){		// 判断，如果有相邻相同点，则返回null		if(firPoint.x == secPoint.x && firPoint.y == secPoint.y) {			firPoint = new SuperMap.Geometry.Point(secPoint.x * 2 - thiPoint.x, secPoint.y * 2 - thiPoint.y);		}		if(thiPoint.x == secPoint.x && thiPoint.y == secPoint.y) {			thiPoint = new SuperMap.Geometry.Point(secPoint.x * 2 - firPoint.x, secPoint.y * 2 - firPoint.y);		}		if((firPoint.x == secPoint.x && firPoint.y == secPoint.y) && (firPoint.x == thiPoint.x && firPoint.y == thiPoint.y)) {			return null;		}				firPoint = toXY(firPoint.x, firPoint.y);		secPoint = toXY(secPoint.x, secPoint.y);		thiPoint = toXY(thiPoint.x, thiPoint.y);		//第三点到到第二点的距离		var y32 = thiPoint.y - secPoint.y,			x32 = thiPoint.x - secPoint.x,						//第二点到第一点的距离			y21 = secPoint.y - firPoint.y,			x21 = secPoint.x - firPoint.x,						//当前线段与x轴正方向的夹角			angle32,angle21,						//两条线段夹角的一半			half,						//两条线段的角平分线与x轴正方向的夹角			r,			//平行线上与对应当前点的坐标经纬度差			lat,lng;				//如果x32为零，则说明此线段垂直于x轴		if (x32 == 0){			angle32 = Math.PI/2;			if (y32 < 0) angle = -angle;		}else{			angle32 = Math.atan(y32/x32);		}		//如果x21为零，则说明此线段垂直于x轴		if (x21 == 0){			angle21 = Math.PI/2;			if (y21 < 0) angle21 = -angle21;		}else{			angle21 = Math.atan(y21/x21);		} 		//如果第三点的x值小于第二点的x值,角度落在二三象限，加上PI进行转换		if( thiPoint.x < secPoint.x){			angle32 += Math.PI;		}		//如果第二点的x值小于第一点的x值,角度落在二三象限，加上PI进行转换		if( secPoint.x < firPoint.x){			angle21 += Math.PI;		}				half = (angle21 - angle32 - Math.PI)/2;		r = angle32 + half;				lenLat = distance / Math.sin(half) * Math.sin(r);		lenLng = distance / Math.sin(half) * Math.cos(r);		return {lat:lenLat, lng:lenLng};	}		return eval(MapFactory.GenerateAPI(api));});